# 项目学习记录

## 前端

### 在html5中新增了type=number的类型,这中间是有坑的

```
在HTML5中，新增了type=number的类型，这个类型有一些隐藏的问题。

在W3C规范中，如果输入了一些非数字的字符，就会返回空字符串。

意思就是你无法用$('#id').val()获取他的值,获取的为空
```



### kendo ui 添加加载效果

```javascript
//对要锁定的dom元素添加id
<body id="page">...</body>

//找出要锁定的元素
var ajaxContainer = $("#page");  

//锁定，并显示加载动画
kendo.ui.progress(ajaxContainer, true);

//解除锁定
kendo.ui.progress(ajaxContainer, false);
```



### js的checkbox的值就是他显示的值,怎么获取选中和不选中状态的两种值

```js
<input id="cityChosen" type="checkbox" value="0">

var cityChosen = $('#cityChosen').val()//这样不管你选没选中,获得值都是 0 

//如果你想要在选中或不选中状态的值不同可以用下面的方法
var cityChosen = $('#cityChosen').prop('checked')?$('#cityChosen').val():''//选中获取0,未选中为''

```



### a标签在跳转到href地址前会先触发它定义的click事件

```javascript
//因为有些时候需要在跳转链接前发送ajax等进行校验,这时候我们就需要利用ajax的这个特性
//函数里面的这个this很精髓,代表这个a标签本身
<a href='www.baidu.com' onclick='beforeClick(this)'/>
//然后我们点击这个a标签,他就会触发函数
    function beforeClick(a){
    console.log(a.href)//输出的就是www.baidu.com
    //发送ajax
            $.ajax({
            type: "post",
            url: "你要进行校验的地址~~~",
            async: false,
            success: function (result) {
                if (result.status != "success") {
                   //如果校验失败,那么就需要处理
                    //你可以设置a的href为#,让他不跳转
                    a.href = '#'
                    return
                }
                    //如果校验成功,那就不需要处理,他就会自动跳转a标签里面的href地址
            }
        });

}
```



### 移动端的alert和confirm函数会显示网站链接,通过下面两端js可以去除

```javascript
/**
     * 去掉移动端alert弹出框携带url链接
     */   
    window.alert = function(name){
        var iframe = document.createElement("IFRAME");
        iframe.style.display="none";
        iframe.setAttribute("src", 'data:text/plain,');
        document.documentElement.appendChild(iframe);
        window.frames[0].window.alert(name);
        iframe.parentNode.removeChild(iframe);
    };



 /**
     * 去掉移动端confirm弹出框携带url链接
     */
    window.confirm = function (message) {
        var iframe = document.createElement("IFRAME");
        iframe.style.display = "none";
        iframe.setAttribute("src", 'data:text/plain,');
        document.documentElement.appendChild(iframe);
        var alertFrame = window.frames[0];
        var result = alertFrame.window.confirm(message);
        iframe.parentNode.removeChild(iframe);
        return result;
    };

```



### url上拼接json格式的字符串会出现问题

```js
url上拼接json格式的字符串,url会自动将引号转译，但是不会自动转译{}，{}需要手动转译,导致程序接受参数错误

解决办法
var json = '{data:"123"}';
var encodeJson = encodeURI(json)
```



### js判断访问的是什么浏览器

```javascript
function myBrowser()
{
    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
    var isOpera = userAgent.indexOf("Opera") > -1;
    if (isOpera)
    {
        return "Opera"
    }; //判断是否Opera浏览器
    if (userAgent.indexOf("Firefox") > -1)
    {
        return "FF";
    } //判断是否Firefox浏览器
    if (userAgent.indexOf("Chrome") > -1)
    {
        return "Chrome";
    }
    if (userAgent.indexOf("Safari") > -1)
    {
        return "Safari";
    } //判断是否Safari浏览器
    if (userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera)
    {
        return "IE";
    }; //判断是否IE浏览器

    if (!!window.ActiveXObject || "ActiveXObject" in window)
    {
        return "IE";
    }
    return "Unknown";
}
```

##### 

### ios的safrai无法利用new Date()函数转换问题

```javascript
当我们用JavaScript实例化一个日期对象时，我们可以这样用:
var date =new Date();
上面这段代码是获取当前日期，这段代码在Firefox、Chrome、Safari浏览器中都可以运行。但是如果我想根据字符串获取日期，问题就来了。看下面代码。

var date =new Date("2016-05-31 08:00");
这段代码是获得字符中指定的日期，它Firefox、Chrome中就能运行，但是放在Safari就会报错，错误是NaN，意思是Not a Number。

safari能解析下面这种格式的数据
var date =new Date("2016/05/31 08:00");


function GetIosDateFormat(timeStr) {
    //将xxxx-xx-xx的时间格式，转换为 xxxx/xx/xx的格式 
    return timeStr.replace(/\-/g, "/");
};

```



### Js判断数组中是否含有这个元素,绝对不能使用in	

```javascript
哦 lz在这个需求里千万不能用in操作符
in 是说存不存在这个key而不是value！

var a = [66,99,77];
66 in a //false
0 in a  //true
var vv = {aa:11,bb:22};
"aa" in vv; //true
"cc" in  vv //false
做实验的时候很容易 试成这样

var a = [1,2,3]; //undefined
1 in a; //true
```



### js判断是否存在某个元素

```javascript
arr.indexOf(元素)>-1 //说明存在这个元素
```



### 使用liMarquee.js实现数据走马灯的效果

```javascript
在使用liMarquee.js的时候发现:
当在前台页面里面的div里预先写好的内容,liMarquee.js可以触发,当通过ajax动态添加数据的时候,发现走马灯就不走了

原因分析:
我怀疑liMarquee只能加载预先处理好的数据

解决方法
在ajax调用的回调函数里,调用liMarquee的初始化方法,就可以解决这个问题
```



### 使用console.log()打印dom元素,查找需要使用的属性

```
需要学会使用console.log()打印出我们要使用的dom元素,然后点开查看,找到我们需要使用的元素
```



### submit引发的问题

```
当使用button的type为submit时,在按钮上添加点击事件,即使,return了,也会触发submit

所以需要进行校验,就不能使用submit类型

但是,如果需要为某些元素赋值,就可以利用这个特性
```



### mCustomScrollbar再次渲染无效

```javascript
滚动条插件mCustomScrollbar，异步加载的过程中当再次渲染区块时，需先销毁之前的渲染：
先销毁:
$(".main_body").mCustomScrollbar("destroy"); //Destroy
在渲染:
$(".main_body").mCustomScrollbar({
            axis: "y",
            scrollButtons: {enable: true},
            theme: "minimal",
            scrollbarPosition: "outside"
});
```



### JQuery中动态创建元素节点无法触发事件

```javascript
动态创建代码，如下：

<div class="a">点击添加动态元素</div>
<p class="b"></p> <!--动态节点放在p标签中-->
$(".a").click(function(){
    var html = ‘<a class="btn">动态添加的按钮</a>’;
    $(".b").html(html);
})
给创建的”a”标签添加 click 事件
$(".btn").on("click",function(){
    alert(1)
})
这样无法触发alert，因为程序找不到此节点。
在jQuery中有“向未来的元素添加事件处理程序”方法说明，也正是动态创建元素无法触发事件的原因所在


解决方式:
$(‘父元素’).on(‘click’,’动态的子元素’,function(){});
$(‘父元素’).live(‘click’,’动态的子元素’,function(){});
当动态创建元素的父级没有添加事件情况下，动态创建的元素可以用on或live绑定事件；
当动态创建元素的父级有绑定事件情况下，动态创建的元素用on

```



### js获取页面URL信息小总结

```javascript
1.window.location.href (设置或获取整个 URL 为字符串)
//  返回：http://i.cnblogs.com/EditPosts.aspx?opt=1

2、window.location.protocol (设置或获取 URL 的协议部分)
//返回：http:

3、window.location.host (设置或获取 URL 的主机部分)
//返回：i.cnblogs.com

4.window.location.port (设置或获取与 URL 关联的端口号码)
//返回：空字符(如果采用默认的80端口 (update:即使添加了:80)，那么返回值并不是默认的80而是空字符)

5.window.location.pathname (设置或获取与 URL 的路径部分（就是文件地址）)
//返回：/EditPosts.aspx

6、window.location.search (设置或获取 href 属性中跟在问号后面的部分)
//返回：?opt=1
//（PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用javascript来获得相信应的参数值。）

7.window.location.hash (设置或获取 href 属性中在井号“#”后面的分段)
//返回：空字符(因为url中没有)
                        
8.js获取url中的参数值*
8.1 正则法
function getQueryString(name) {
          var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
          var r = window.location.search.substr(1).match(reg);

          if (r != null) {
             return unescape(r[2]);
          }
          return null;
  }
// 这样调用：
GetQueryString("参数名1")

8.2 split拆分法
function GetRequest() {
         var url = location.search; //获取url中"?"符后的字串
         var theRequest = new Object();

         if (url.indexOf("?") != -1) {
                 var str = url.substr(1);
                 strs = str.split("&");
              for(var i = 0; i < strs.length; i ++) {
                      theRequest[strs[i].split("=")[0]] = unescape(strs[i].split("=")[1]);
               }
         }
     return theRequest;
 }
// 这样调用:
var Request = new Object();
Request = GetRequest();<br>// var id=Request["id"]; 

8.3 指定取
function GetQueryString(name) { 
         var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i"); 
         var r = window.location.search.substr(1).match(reg); //获取url中"?"符后的字符串并正则匹配
         var context = ""; 

     if (r != null) 
     context = r[2]; 
    reg = null; 
    r = null; 
    return context == null || context == "" || context == "undefined" ? "" : context; 
 }

//这样调用
GetQueryString("j")

8.4 单个参数的获取方法
function GetRequest() {
         var url = location.search; //获取url中"?"符后的字串
         if (url.indexOf("?") != -1) {? //判断是否有参数
                  var str = url.substr(1); //从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串
                  strs = str.split("=");? //用等号进行分隔 （因为知道只有一个参数 
                                          //所以直接用等号进分隔 如果有多个参数 要用&号分隔 再用等号进行分隔）
                  alert(strs[1]);???? //直接弹出第一个参数 （如果有多个参数 还要进行循环的）
         }
  }
```



### 动态加载swiper,默认显示最后一个swiper-slide

```javascript
动态获取数据并渲染后，添加MySwiper.update(); MySwiper 是 new Swiper()的实例名。

//动态获取数据并渲染后，添加MySwiper.update(); MySwiper 是 new Swiper()的实例名。
$.post('','',function(data){
  $(".container").html(data);
  MySwiper.update();
});
var mySwiper = new Swiper('.swiper-container',{
pagination : '.swiper-pagination',
});
```



### echarts重新渲染的问题,当无数据显示'暂无数据',当有数据显示图表,无法重新加载的问题

```javascript
1.在 echarts 正常渲染后，会在容器 div 上面添加一个自定义的属性 _echarts_instance_，比如 <div id="ec_container" _echarts_instance_="ec_1543635936716"></div>

2.假设 echarts 里面的数据都是从 ajax 的方式来获取的，当某一次数据请求失败的时候，会在 div#ec_container 里面插入 一段 html ，比如 <span>暂无数据</span>，此时的 div#ec_container 变成了 <div id="ec_container" _echarts_instance_="ec_1543635936716"><span>暂无数据</span></div>

3.当再次切换搜索条件，获取新的数据的时候，ajax请求成功，数据也是没问题的，但是此时 echarts 图 渲染不出来，页面上面依然显示的是 “暂无数据”，此时的 div#ec_container 依然是 <div id="ec_container" _echarts_instance_="ec_1543635936716"><span>暂无数据</span></div>。

4.无意中，我发现当我手动把 div#ec_container 的自定义属性 echarts_instance 去掉之后，再获取数据的时候，echarts 图能够正常渲染。

5.所以我的解决办法是：当获取数据失败，往 div#ec_container 容器中插入 <span>暂无数据</span> html 片段之后，手动删除掉 div#ec_container 容器的 echarts_instance，这样问题就解决了。

6.具体代码呢，类似于是这样的
$('#rate_pie').html('<span>暂无数据</span>');
// 必须手动去掉 echarts 容器上面的 属性 _echarts_instance_ ，否则下次echarts图无法正常显示，具体原理未知
$('#rate_pie').removeAttr('_echarts_instance_');
```



### 禁用kendo的grid的y轴滚动条

```css
//添加样式
 .k-grid-content {
       overflow-y: hidden;
    }
```



### js语法,将str转换成json对象,json对象转换成str

```js
//由字符串转json的三种方式
//第一种
var json = JSON.parse(str);
//第二种
var json = eval("(" + str + ")");
//第三种
//var json = 	
    
    
//json转字符串
 var str = JSON.stringify(jsonobj);

//可能遇到的坑
//当你的变量已经是json对象的时候,转换就会出现问题
var json = {"aaa":"bbb"}
console.log(json)//[object object]
//此时你在使用字符串转json就会报错.o的错误

//获得json数据的方式
var a = json['aaa']//a=bbb

```



## 后端

### @Valid注解对List失效

```java
@Valid只能校验JavaBean，而List不是JavaBean所以校验会失败，解决方案如下：


@Data
public class ListWrapper<E> {
 
    @NotEmpty
    @Valid
    private List<E> list;
 
    public ListWrapper() {
        list = new ArrayList<>();
    }
 
    public ListWrapper(List<E> list) {
        this.list = list;
    }
}
```



### @Valid怎么校验对象中的对象

```java
public Object testOne(@RequestBody @Valid Dto dto) {}


public class Dto {
    private Student student;
    @Valid//添加这个注解可以级联到下一个对象
    private Teacher teacher;
    }
}

public class Teacher {

    @NotNull(message = "教师id不能为空")
    private Integer id;
    @NotBlank(message = "教师名字不能为空")
    private String teacherName;
}
```



### String以"."切割小数点

```java
"a"

```


### 处理同一条记录时候的并发问题--添加乐观锁

```
乐观锁
使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据


1.如为我的表添加一个last_update_time字段,设置为数据库默认时间sysdate
2.当修改数据时,肯定会查询数据库,然后获得的数据里就会有last_update_time的信息
3.修改数据时使用一下sql
 update 表 set 字段 = 新的值, last_update_time =  sysdate where  id = ID值 and last_update_time = last_update_time
 4.当用户a和用户b同事打开数据时,此时a先修改,那么last_update_time就会变化,b再去更新时就找不到这一条记录,就无法修改了,此时可以抛出异常,这样就保证了数据的一致性了

```



### InputStream的available()方法读取数据不完全

```
在前面开发base64转码图片的过程,我遇到了获取互联网端的图片,图片的大小进行转码,图片显示不全的问题,后面思考发现,可能是流没有读取完全,然后发现了其调用的是InputStream的available的方法,参考下面的方法描述可知,他是估计流的大小,所以他估计的可能不准确,导致数据的缺失,从而导致base64转码不全


'InputStream类下的available方法返回从该输入流中可以读取（或跳过）的字节数的估计值，而不会被下一次调用此输入流的方法阻塞。 下一个调用可能是同一个线程或另一个线程。 这个多个字节的单个读取或跳过将不会被阻塞，但可以读取或跳过较少的字节。'
```



### Base64转码图片遇到的问题

```java
//将图片转码成base64格式,仅支持本地转码
    public static String GetImageStr(String imgFile){
        //将图片文件转化为字节数组字符串，并对其进行Base64编码处理
        InputStream in = null;
        byte[] data = null;
        //读取图片字节数组
        try
        {
//当io流读取的文件是本地文件,可以使用这种式,C:\hzzhgl\uploadFile\3D616075A8304C599E0075F68F3589BA.jpg
            in = new FileInputStream(imgFile);
            data = new byte[in.available()];
            in.read(data);
            in.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        //对字节数组Base64编码
        BASE64Encoder encoder = new BASE64Encoder();
        //返回Base64编码过的字节数组字符串
        return encoder.encode(data);
    }

//当你要转码的图片来自服务器端或者互联网,则需要使用下面这种方式
    public static String GetImageStr(String imgFile){
        //将图片文件转化为字节数组字符串，并对其进行Base64编码处理
        InputStream in = null;
        byte[] data = null;
        //读取图片字节数组
        try
        {

//当io流读取的文件来自服务器端,可以使用下面这种方式,如http://172.20.40.17/hyassets/images/menu/app-img-BASEDATA.png
            /**
            *这种方式也是有问题的,加载不完全
            */
           // in = new URL(imgFile).openStream();
            //data = new byte[in.available()];
            //in.read(data);
            //in.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
        //对字节数组Base64编码
        BASE64Encoder encoder = new BASE64Encoder();
        //返回Base64编码过的字节数组字符串
        return encoder.encode(data);
    }



/**
     * 图片转化成base64字符串
     *
     * @param imgFile
     * @return
     */
    public static String GetImageStr(String imgFile) {
        //将图片文件转化为字节数组字符串，并对其进行Base64编码处理
        InputStream in = null;
        byte[] data = null;
        HttpURLConnection httpUrl = null;
        URL url = null;
        //读取图片字节数组
        try {
            url = new URL(imgFile);
            httpUrl = (HttpURLConnection) url.openConnection();
            httpUrl.connect();
            data = read(httpUrl.getInputStream());
        } catch (IOException e) {
            e.printStackTrace();
        }
        //对字节数组Base64编码
        BASE64Encoder encoder = new BASE64Encoder();
        //返回Base64编码过的字节数组字符串
        return encoder.encode(data);
    }


    public static byte[] read(InputStream inputStream) throws IOException {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            byte[] buffer = new byte[1024];
            int num = inputStream.read(buffer);
            while (num != -1) {
                baos.write(buffer, 0, num);
                num = inputStream.read(buffer);
            }
            baos.flush();
            return baos.toByteArray();
        } finally {
            if (inputStream != null) {
                inputStream.close();
            }
        }
    }
```



### Calendar的坑,roll是有范围限制的

```java
Date date = DateUtil.formatStringToDate("2019-03-01 11:00:00");
Calendar calendar = Calendar.getInstance();
calendar.setTime(date);
//calendar.roll(Calendar.SECOND, -1);//当时间为整点的时候,倒退一秒,输出 2019-03-01 11:00:59
//calendar.roll(Calendar.MINUTE, -1);//当时间为整点的时候,倒退一分钟,输出 2019-03-01 11:59:00
//calendar.roll(Calendar.DAY_OF_MONTH, -1);//当时间为某月第一天的时候,输出2019-03-31 11:00:00
//calendar.roll(Calendar.DAY_OF_YEAR, -1);//当时间为某月第一天的时候,输出2019-02-28 11:00:00
//calendar.roll(Calendar.MONTH, -4);//当时间为3月,回滚4个月,输出2019-11-01 11:00:00


/**
 *  由上面可知roll是有范围的,他只会在他的范围内变化,不会影响其他范围的变化,比如设置为Calendar.SECOND,
 * 	他可以在0~59的范围内变化,但是不会影响MINUTE的变化,所以在使用的时候我们得小心
 */
```





### 手机在提交的时候添加loading效果

```javascript
//在页面未加载完毕之前显示的loading Html自定义内容
//第二个div给整个页面打上一层蒙版
//第三个div设置loading.gif的位置,可根据实际大小进行调整
var _LoadingHtml = '<div id="loadingDiv" style="display: none; "><div id="over" style=" position: absolute;top: 0;left: 0; width: 100%;height: 100%; background-color: #f5f5f5;opacity:0.5;z-index: 1000;"></div><div id="layout" style="position: absolute;top: 40%; left: 40%;width: 20%; height: 20%;  z-index: 1001;text-align:center;"><img src="/js/plugins/layer/skin/default/loading-0.gif" /></div></div>';
//呈现loading效果
document.write(_LoadingHtml);
 
//移除loading效果
function completeLoading() {  
		document.getElementById("loadingDiv").style.display="none";
}
//展示loading效果
function showLoading()
{
document.getElementById("loadingDiv").style.display="block";
    
    
```



### long类型的数据强制转换成int类型数据会出现问题

```java
//当long类型的数据转换成int格式的数据时
//因为int有精度限制为32位,而long类型的数据精度为64位,当一个超出int长度限制的long类型转换为int时,会出现负数
  Date now = new Date();
  long longTime = now.getTime();
  int intTime = (int) longTime ''
  System.out.println("long类型的数据:" + longTime);//long类型的数据:1551403445319
  System.out.println("int类型的数据:" + intTime);//int类型的数据:920251463
//两者存在差异
```



### HttpClient发送json格式数据,接口无法解析

```java
没有设置请求体里面的数据格式,对方无法识别
EmergencyVehicleParam emergencyVehicleParam = new EmergencyVehicleParam(KEY,EMERGENCY_VEHICLE_LIST);
String jsonStr = JSONObject.toJSONString(emergencyVehicleParam);
StringEntity entity = new StringEntity(jsonStr, "utf-8");
//在这里要告诉调用的接口,你的请求体里面是怎样的数据格式
entity.setContentType("application/json");
httpPost.setEntity(entity);
```



### java正则表达式手机号码说明

```
(15[^4,\D])
这个表达式标明的是手机号在15段,除4以外的所有数字,类似于15[012356789]
```



### java泛型:<? extends xxx>中的?和extends的理解和使用实例

```
?表示的是xxx这个类的子类型,extends表示的是子类型,不等同于继承
```



### @Deprecated注解的功能

```
某个类或者某个方法添加上这个注解后,表示此方法或类不再建议使用,使用时会出现删除线
```



### WS和WSS

```
WS就是websocket,wss就是加密的websocket;就如http和https一样
```



### SpringMvc的@ModelAttribute注解的使用

```
1.被@ModelAttribute注解注释的方法会在Controller每个方法执行前执行:
2.运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用；
3.运用在方法上，会在每一个@RequestMapping标注的方法前执行，如果有返回值，则自动将该返回值加入到ModelMap中；
```



### java8里面的::表示什么

```java
双冒号运算就是Java中的[方法引用],[方法引用]的格式是 
类名::方法名。
一般是用作Lambda表达式
例如表达式:person -> person.getName();
可以替换成Person::getName
表达式() -> new HashMap<>();
可以替换成HashMap::new
这种[方法引用]或者说[双冒号运算]对应的参数类型是Function<T,R> T表示传入类型，R表示返回类型。

```



### Excel导出功能

```java
/**
@Retention定义了该Annotation被保留的时间长短。参数为 RetentionPolicy
  SOURCE,     //只在源码中存在，不存在编译后的.class 文件      
    CLASS,      //默认配置，存在于源码，且编译后也存在.class中,但信息不会被加载到JVM虚拟机中
    RUNTIME;    //源码、class文件、虚拟机中都存在
*/

/**
@Target
Target说明了Annotation所修饰的对象范围，参数为 ElementType
    TYPE,                   //用于描述类、接口(包括注解类型) 或enum声明
    FIELD,                  //用于描述属性
    METHOD,                 //用于描述方法
    PARAMETER,              //用于描述参数
    CONSTRUCTOR,            //用于描述构造函数
    LOCAL_VARIABLE,         //用于描述局部变量
    ANNOTATION_TYPE,        //用于描述注解
    PACKAGE,                //用于包
    TYPE_PARAMETER,         //描述类型，如泛型，String类型
    TYPE_USE;               //描述这个注解可以用在类型的声明式前

*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface ExcelAnnotation {
	// excel导出时标题显示的名字，如果没有设置Annotation属性，将不会被导出和导入
	public String exportName();
}
```





### 使用try-with-resources代替try-finally

```java
jdk1.7引入了新的语法,AutoCloseable接口,使得我们关闭资源有了新方式
一些资源也实现了该接口，如preparedStatement、Connection、InputStream、outputStream等等资源接口。在使用的时候只需要把资源在try块中用小括号括起来就可以了,就可以自动关闭资源了。
 /**
     * try-with-resources - the the best way to close resources!
     * @param path
     * @return
     * @throws IOException
     */
    static String firstLineOfFile(String path) throws IOException {
        try (BufferedReader bufferedReader = new BufferedReader(new FileReader(path))) {
            return bufferedReader.readLine();
        }
    }

 /**
     * try-with-resources on multiple resources - short and sweet
     * @param src
     * @param dest
     * @throws IOException
     */
    static void copy(String src, String dest) throws IOException {
        try (InputStream inputStream = new FileInputStream(src);
             OutputStream outputStream = new FileOutputStream(dest)) {
            byte[] buf = new byte[1024];
            int n;
            while ((n = inputStream.read(buf))>=0) {
                outputStream.write(buf, 0, n);
            }
        }
    }

```



### springboot整合swagger2遇到的问题

```
在配置完swagger2之后,访问swagger-ui.html界面,遇到Whitelabel Error Page

原因是配置文件中的配置与swagger冲突
需要注释掉spring.mvc.static-path-pattern:static/**

之后即可访问swagger-ui界面
```



### java.lang.UnsupportedClassVersionError

```
出现java.lang.UnsupportedClassVersionError 错误的原因，是因为我们使用高版本的JDK编译的Java class文件试图在较低版本的JVM上运行，所报的错误

因为，高版本的JDK生成的class文件使用的格式，可能与低版本的JDK的.class文件格式不同。这样，低版本的JVM无法解释执行这个.class文件，会抛出java.lang.UnsupportedClassVersionError不支持的Class版本错误。

这个错误尤其在JDK5与JDK5之前的版本上表现明显。因为，JDK5在Java语法上作了不少增强，引入了一些新的.class文件的元素，导致旧版本的JVM无法解释、执行.class文件。即使这个类并没有使用任何JDK5的新元素，但是JDK5生成的.class文件，JDK1.4及其以前的JVM都无法辨认！
```



### 使用apache Ftpserver上传文件一直报错java.net.SocketException: Software caused connection abort: socket write error

```
当使用apache ftpserver上传文件的时候,一直报错,说java.net.SocketException: Software caused connection abort: socket write error

然后我就打断点进去查看,一直查看到socket创建,发现创建了socket为本机Ipv4地址+一个端口

然后我使用telnet测试该端口是否可用,测试发现,端口可用,证明端口是没有问题的,但是走下一步,还是会出现上述的问题

最后检查发现需要关闭本机的防火墙,关闭就没有问题了?原因还不知道,好像是防火墙会阻止socket通信
```



### Assert的使用

```java
Assert断言工具类，通常用于数据合法性检查

在JAVA编程中，通常会编写如下代码：  
if (name == null || name.equls("")) { 
    throw new IllegalArgumentException("参数错误!"); 
}  

在所有方法中都使用手工检测合法性的方式并不是太好，因为这样影响了代码的可读性，若使用Assert工具类上面的代码可以简化为： 
Assert.hasText((name, "参数错误!");
               
1. notNull(Object object) 
当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null；

2. isTrue(boolean expression) / isTrue(boolean expression, String message) 
当 expression 不为 true 抛出异常；

3. notEmpty(Collection collection) / notEmpty(Collection collection, String message) 
当集合未包含元素时抛出异常。
notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断；

4. hasLength(String text) / hasLength(String text, String message) 

当 text 为 null 或长度为 0 时抛出异常；

5. hasText(String text) / hasText(String text, String message) 

text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常；

6. isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message) 

如果 obj 不能被正确造型为 clazz 指定的类将抛出异常；

7. isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message) 

subType 必须可以按类型匹配于 superType，否则将抛出异常；
```





### java使用FTP上传图片，在Windows下可以用，到linux下就不能用了

```
在项目中使用commons-net-3.0.1.jar实现FTP文件的下载，在windows xp上运行正常，但是放到linux上，却出现问题，程序运行到

FTPClient.listFiles()或者FTPClient.retrieveFile()方法时，就停止在那里，什么反应都没有，出现假死状态。google一把，发现很多人也出现了此类问题，最终在一个帖子里找到了解决办法。在调用这两个方法之前，调用FTPClient.enterLocalPassiveMode();这个方法的意思就是每次数据连接之前，ftp client告诉ftp server开通一个端口来传输数据。为什么要这样做呢，因为ftp server可能每次开启不同的端口来传输数据，但是在linux上或者其他服务器上面，由于安全限制，可能某些端口没有开启，所以就出现阻塞。OK，问题解决。



另外，如果程序部署在weblogic上， 也有可能出现一些问题，为什么，因为weblogic自己也有commons-net包，如果weblogic的jar包版本低于你使用的版本，就设置weblogic 的classpath，优先加载工程里的jar包。

```



### 解决xss漏洞

```java
网站中包含大量的动态内容以提高用户体验，比过去要复杂得多。所谓动态内容，就是根据用户环境和需要，Web应用程序能够输出相应的内容。动态站点会受到一种名为“跨站脚本攻击”（Cross Site Scripting, 安全专家们通常将其缩写成XSS,原本应当是css，但为了和层叠样式表（Cascading Style Sheet,CSS ）有所区分，故称XSS）的威胁，而静态站点则完全不受其影响。

用户在浏览网站、使用即时通讯软件、甚至在阅读电子邮件时，通常会点击其中的链接。攻击者通过在链接中插入恶意代码，就能够盗取用户信息。攻击者通常会用十六进制（或其他编码方式）将链接编码，以免用户怀疑它的合法性。网站在接收到包含恶意代码的请求之后会产成一个包含恶意代码的页面，而这个页面看起来就像是那个网站应当生成的合法页面一样。许多流行的留言本和论坛程序允许用户发表包含HTML和javascript的帖子。假设用户甲发表了一篇包含恶意脚本的帖子，那么用户乙在浏览这篇帖子时，恶意脚本就会执行，盗取用户乙的session信息。有关攻击方法的详细情况将在下面阐述。

java解决方法:采用过滤器的方法在获取参数的时候对入参进行特殊字符格式化

第一步,创建request包装类,对request请求进行处理
package com.supconit.zhgl.web.common;

import org.springframework.web.util.HtmlUtils;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.util.Map;

/**
 * @ClassName XssHttpServletRequestWrapper
 * @Description 对Http的request请求进行包装
 * @Author 刘嘉杰
 * @Date 2019/10/14 14:19
 * @Version 1.0
 */
public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {

    final String[] excludeParam = {"_bpm_extra_params"};

    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }

    /**
     * 覆盖getParameter方法，将参数名和参数值都做xss过滤。
     * 如果需要获得原始的值，则通过super.getParameterValues(name)来获取
     * getParameterNames,getParameterValues和getParameterMap也可能需要覆盖
     */
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        if (value != null) {
            value =  HtmlUtils.htmlEscape(value);
        }
        return value;
    }

    @Override
    public String[] getParameterValues(String name) {
        //不想过滤的参数，此处content参数是 富文本内容
        for (String s : excludeParam) {
            if(s.equals(name)){
                return super.getParameterValues(name);
            }
        }

        String[] values = super.getParameterValues(name);
        if (values != null) {
            String[] newValues = new String[values.length];
            for (int i = 0; i < values.length; i++) {
                //spring的HtmlUtils进行转义
                newValues[i] = HtmlUtils.htmlEscape(values[i]);
            }
            return newValues;
        }
        return values;

    }
    @Override
    public Map getParameterMap() {
        // TODO Auto-generated method stub
        return super.getParameterMap();
    }
}


第二步,创建过滤器,对请求进行处理
package com.supconit.zhgl.web.common.filter;


import com.supconit.zhgl.web.common.XssHttpServletRequestWrapper;

import javax.servlet.*;
import javax.servlet.http.HttpServletRequest;
import java.io.IOException;

/**
 * @ClassName XssFilter
 * @Description 解决xss漏洞
 * @Author 刘嘉杰
 * @Date 2019/10/14 14:17
 * @Version 1.0
 */
public class XssFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        XssHttpServletRequestWrapper xssHttpServletRequestWrapper = new XssHttpServletRequestWrapper((HttpServletRequest) servletRequest);
        filterChain.doFilter(xssHttpServletRequestWrapper, servletResponse);
    }

    @Override
    public void destroy() {

    }
}

第三步,在web.xml中配置过滤器
	<filter>
		<filter-name>XssFilter</filter-name>
		<filter-class>com.supconit.zhgl.web.common.filter.XssFilter</filter-class>
	</filter>
	<filter-mapping>
		<filter-name>XssFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>

```



### csrf漏洞

```java
CSRF 背景与介绍
CSRF（Cross Site Request Forgery, 跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一。其他安全隐患，比如 SQL 脚本注入，跨站域脚本攻击等在近年来已经逐渐为众人熟知，很多网站也都针对他们进行了防御。然而，对于大多数人来说，CSRF 却依然是一个陌生的概念。即便是大名鼎鼎的 Gmail, 在 2007 年底也存在着 CSRF 漏洞，从而被黑客攻击而使 Gmail 的用户造成巨大的损失。

CSRF 攻击实例
CSRF 攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。比如说，受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 http://bank.example/withdraw?account=bob&amount=1000000&for=bob2 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。

CSRF 攻击的对象
在讨论如何抵御 CSRF 之前，先要明确 CSRF 攻击的对象，也就是要保护的对象。从以上的例子可知，CSRF 攻击是黑客借助受害者的 cookie 骗取服务器的信任，但是黑客并不能拿到 cookie，也看不到 cookie 的内容。另外，对于服务器返回的结果，由于浏览器同源策略的限制，黑客也无法进行解析。因此，黑客无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。所以，我们要保护的对象是那些可以直接产生数据改变的服务，而对于读取数据的服务，则不需要进行 CSRF 的保护。比如银行系统中转账的请求会直接改变账户的金额，会遭到 CSRF 攻击，需要保护。而查询余额是对金额的读取操作，不会改变数据，CSRF 攻击无法解析服务器返回的结果，无需保护。

当前防御 CSRF 的几种策略
在业界目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。

验证 HTTP Referer 字段
根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。

即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。

在请求地址中添加 token 并验证
CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上 <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。

该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。

在 HTTP 头中自定义属性并验证
这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。

然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。

Java 代码示例
下文将以 Java 为例，对上述三种方法分别用代码进行示例。无论使用何种方法，在服务器端的拦截器必不可少，它将负责检查到来的请求是否符合要求，然后视结果而决定是否继续请求或者丢弃。在 Java 中，拦截器是由 Filter 来实现的。我们可以编写一个 Filter，并在 web.xml 中对其进行配置，使其对于访问所有需要 CSRF 保护的资源的请求进行拦截。

在 filter 中对请求的 Referer 验证代码如下

清单 1. 在 Filter 中验证 Referer
// 从 HTTP 头中取得 Referer 值
String referer=request.getHeader("Referer"); 
// 判断 Referer 是否以 bank.example 开头
if((referer!=null) &&(referer.trim().startsWith(“bank.example”))){ 
   chain.doFilter(request, response); 
}else{ 
   request.getRequestDispatcher(“error.jsp”).forward(request,response); 
}
以上代码先取得 Referer 值，然后进行判断，当其非空并以 bank.example 开头时，则继续请求，否则的话可能是 CSRF 攻击，转到 error.jsp 页面。

如果要进一步验证请求中的 token 值，代码如下

清单 2. 在 filter 中验证请求中的 token
HttpServletRequest req = (HttpServletRequest)request; 
HttpSession s = req.getSession(); 
 
// 从 session 中得到 csrftoken 属性
String sToken = (String)s.getAttribute(“csrftoken”); 
if(sToken == null){ 
 
   // 产生新的 token 放入 session 中
   sToken = generateToken(); 
   s.setAttribute(“csrftoken”,sToken); 
   chain.doFilter(request, response); 
} else{ 
 
   // 从 HTTP 头中取得 csrftoken 
   String xhrToken = req.getHeader(“csrftoken”); 
 
   // 从请求参数中取得 csrftoken 
   String pToken = req.getParameter(“csrftoken”); 
   if(sToken != null && xhrToken != null && sToken.equals(xhrToken)){ 
       chain.doFilter(request, response); 
   }else if(sToken != null && pToken != null && sToken.equals(pToken)){ 
       chain.doFilter(request, response); 
   }else{ 
       request.getRequestDispatcher(“error.jsp”).forward(request,response); 
   } 
}
首先判断 session 中有没有 csrftoken，如果没有，则认为是第一次访问，session 是新建立的，这时生成一个新的 token，放于 session 之中，并继续执行请求。如果 session 中已经有 csrftoken，则说明用户已经与服务器之间建立了一个活跃的 session，这时要看这个请求中有没有同时附带这个 token，由于请求可能来自于常规的访问或是 XMLHttpRequest 异步访问，我们分别尝试从请求中获取 csrftoken 参数以及从 HTTP 头中获取 csrftoken 自定义属性并与 session 中的值进行比较，只要有一个地方带有有效 token，就判定请求合法，可以继续执行，否则就转到错误页面。生成 token 有很多种方法，任何的随机算法都可以使用，Java 的 UUID 类也是一个不错的选择。

除了在服务器端利用 filter 来验证 token 的值以外，我们还需要在客户端给每个请求附加上这个 token，这是利用 js 来给 html 中的链接和表单请求地址附加 csrftoken 代码，其中已定义 token 为全局变量，其值可以从 session 中得到。

清单 3. 在客户端对于请求附加 token
function appendToken(){ 
   updateForms(); 
   updateTags(); 
} 
 
function updateForms() { 
   // 得到页面中所有的 form 元素
   var forms = document.getElementsByTagName('form'); 
   for(i=0; i<forms.length; i++) { 
       var url = forms[i].action; 
 
       // 如果这个 form 的 action 值为空，则不附加 csrftoken 
       if(url == null || url == "" ) continue; 
 
       // 动态生成 input 元素，加入到 form 之后
       var e = document.createElement("input"); 
       e.name = "csrftoken"; 
       e.value = token; 
       e.type="hidden"; 
       forms[i].appendChild(e); 
   } 
} 
 
function updateTags() { 
   var all = document.getElementsByTagName('a'); 
   var len = all.length; 
 
   // 遍历所有 a 元素
   for(var i=0; i<len; i++) { 
       var e = all[i]; 
       updateTag(e, 'href', token); 
   } 
} 
 
function updateTag(element, attr, token) { 
   var location = element.getAttribute(attr); 
   if(location != null && location != '' '' ) { 
       var fragmentIndex = location.indexOf('#'); 
       var fragment = null; 
       if(fragmentIndex != -1){ 
 
           //url 中含有只相当页的锚标记
           fragment = location.substring(fragmentIndex); 
           location = location.substring(0,fragmentIndex); 
       } 
        
       var index = location.indexOf('?'); 
 
       if(index != -1) { 
           //url 中已含有其他参数
           location = location + '&csrftoken=' + token; 
       } else { 
           //url 中没有其他参数
           location = location + '?csrftoken=' + token; 
       } 
       if(fragment != null){ 
           location += fragment; 
       } 
        
       element.setAttribute(attr, location); 
   } 
}
在客户端 html 中，主要是有两个地方需要加上 token，一个是表单 form，另一个就是链接 a。这段代码首先遍历所有的 form，在 form 最后添加一隐藏字段，把 csrftoken 放入其中。然后，代码遍历所有的链接标记 a，在其 href 属性中加入 csrftoken 参数。注意对于 a.href 来说，可能该属性已经有参数，或者有锚标记。因此需要分情况讨论，以不同的格式把 csrftoken 加入其中。

如果你的网站使用 XMLHttpRequest，那么还需要在 HTTP 头中自定义 csrftoken 属性，利用 dojo.xhr 给 XMLHttpRequest 加上自定义属性代码如下：

清单 4. 在 HTTP 头中自定义属性
var plainXhr = dojo.xhr; 
 
// 重写 dojo.xhr 方法
dojo.xhr = function(method,args,hasBody) { 
   // 确保 header 对象存在
   args.headers = args.header || {}; 
        
   tokenValue = '<%=request.getSession(false).getAttribute("csrftoken")%>'; 
   var token = dojo.getObject("tokenValue"); 
    
   // 把 csrftoken 属性放到头中
   args.headers["csrftoken"] = (token) ? token : "  "; 
   return plainXhr(method,args,hasBody); 
};
这里改写了 dojo.xhr 的方法，首先确保 dojo.xhr 中存在 HTTP 头，然后在 args.headers 中添加 csrftoken 字段，并把 token 值从 session 里拿出放入字段中。

CSRF 防御方法选择之道
通过上文讨论可知，目前业界应对 CSRF 攻击有一些克制方法，但是每种方法都有利弊，没有一种方法是完美的。如何选择合适的方法非常重要。如果网站是一个现有系统，想要在最短时间内获得一定程度的 CSRF 的保护，那么验证 Referer 的方法是最方便的，要想增加安全性的话，可以选择不支持低版本浏览器，毕竟就目前来说，IE7+, FF3+ 这类高版本浏览器的 Referer 值还无法被篡改。

如果系统必须支持 IE6，并且仍然需要高安全性。那么就要使用 token 来进行验证，在大部分情况下，使用 XmlHttpRequest 并不合适，token 只能以参数的形式放于请求之中，若你的系统不支持用户自己发布信息，那这种程度的防护已经足够，否则的话，你仍然难以防范 token 被黑客窃取并发动攻击。在这种情况下，你需要小心规划你网站提供的各种服务，从中间找出那些允许用户自己发布信息的部分，把它们与其他服务分开，使用不同的 token 进行保护，这样可以有效抵御黑客对于你关键服务的攻击，把危害降到最低。毕竟，删除别人一个帖子比直接从别人账号中转走大笔存款严重程度要轻的多。

如果是开发一个全新的系统，则抵御 CSRF 的选择要大得多。笔者建议对于重要的服务，可以尽量使用 XMLHttpRequest 来访问，这样增加 token 要容易很多。另外尽量避免在 js 代码中使用复杂逻辑来构造常规的同步请求来访问需要 CSRF 保护的资源，比如 window.location 和 document.createElement(“a”) 之类，这样也可以减少在附加 token 时产生的不必要的麻烦。

最后，要记住 CSRF 不是黑客唯一的攻击手段，无论你 CSRF 防范有多么严密，如果你系统有其他安全漏洞，比如跨站域脚本攻击 XSS，那么黑客就可以绕过你的安全防护，展开包括 CSRF 在内的各种攻击，你的防线将如同虚设。
```



### restful风格介绍

```java
1，GET 2，HEAD 3，PUT 4，DELETE 5，POST 6，OPTIONS
但其实我们大部分情况下只用到了GET和POST。如果想设计一个符合RESTful规范的web应用程序，则这六种方法都会用到。不过即使暂时不想涉及REST，了解这六种方法的本质仍然是很有作用的。大家将会发现，原来web也是很简洁明了的。下面依次说明这六种方法。
1，GET：GET可以说是最常见的了，它本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。
2，HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。
3，PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。举个例子：如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。
4，DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。
5，POST：向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。
6，OPTIONS：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。
其实还有一个TRACE方法，不过这个基本上不会用到，这里就不介绍了。以上的六种方法，我们可以跟数据库的CRUD增删改查操作对应起来：
CREATE ：PUT READ：GET UPDATE：POST DELETE：DELETE
这样一来就实现了HTTP和数据库操作（其实不光是数据库，任何数据如文件图表都是这样）的完美统一，这也是REST的精髓之一。
```



### @RequestBody的使用

```
http方式调用对方接口,对方接受到的参数为空,
原因

@RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的)；GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。在后端的同一个接收方法里，@RequestBody与@RequestParam()可以同时使用，@RequestBody最多只能有一个，而@RequestParam()可以有多个。

```



### ManagementFactory的使用

```
可以通过这个类获取jvm的各种组件实例,从而获取相关的jvm信息,可以帮助我们进行jvm调优
```



### 字符串中包含"+",该怎么用"+"切割

```java
String[] stringArr = ”60+200“.split("\\+");
```



### 反射无法反射到该类的父类属性和方法

```java
一.项目上项通过反射获取,类的属性,发现获得的属性只能获取子类的属性,无法获取父类的属性
    
package com.test;

import java.lang.reflect.Field;
import java.util.stream.Stream;

/**
 * @author liujiajie
 * @create 2018-12-06 15:37
 */
public class TestDemo {
    public static void main(String[] args) {
        A a = new Aa();
        Aa aa = new Aa();

        Class<? extends A> aClass = a.getClass();
        Class<? extends Aa> aClass1 = aa.getClass();

        Field[] declaredFields = aClass.getDeclaredFields();
        Stream.of(declaredFields).forEach(f -> System.out.println("A:"+f.getName()));
		//输出结果: A: aa

        Field[] declaredFields1 = aClass1.getDeclaredFields();
        Stream.of(declaredFields1).forEach(f -> System.out.println("Aa:"+f.getName()));
    	//输出结果:Aa: aa
    }
}

abstract class A{
  private String a;

    public String getA() {
        return a;
    }

    public void setA(String a) {
        this.a = a;
    }
}

class Aa extends A{
    private String aa;

    public String getAa() {
        return aa;
    }

    public void setAa(String aa) {
        this.aa = aa;
    }
}

二.后面发现,是由于继承的原因,无法获取父类的私有化属性,需要我们获取父类的class类,才可以获取父类的属性
    
package com.test;

import java.lang.reflect.Field;
import java.util.stream.Stream;

/**
 * @author liujiajie
 * @create 2018-12-06 15:37
 */
public class TestDemo {
    public static void main(String[] args) {
        A a = new Aa();
        Aa aa = new Aa();

        Class<? extends A> aClass = a.getClass();
        Class<? extends Aa> aClass1 = aa.getClass();
        //获取Aa的父类class对象
        Class<?> superclass = aClass1.getSuperclass();

        Field[] declaredFields = aClass.getDeclaredFields();
        Stream.of(declaredFields).forEach(f -> System.out.println("A:"+f.getName()));
		//输出结果: A: aa

        Field[] declaredFields1 = aClass1.getDeclaredFields();
        Stream.of(declaredFields1).forEach(f -> System.out.println("Aa:"+f.getName()));
		//输出结果:Aa: aa
        
        Field[] declaredFields2 = superclass.getDeclaredFields();
        Stream.of(declaredFields2).forEach(f -> System.out.println("Aa's superclass:"+f.getName()));
        //输出 Aa's superclass:a

    }
}

abstract class A{
  private String a;

    public String getA() {
        return a;
    }

    public void setA(String a) {
        this.a = a;
    }
}

class Aa extends A{
    private String aa;

    public String getAa() {
        return aa;
    }

    public void setAa(String aa) {
        this.aa = aa;
    }
}


这样就可以获取我们需要的父类的私有化属性
```



### ApplicationContextAware使用理解,并解决过滤器中bean注入为空的问题

```java
在我们的web程序中，用spring来管理各个实例(bean), 有时在程序中为了使用已被实例化的bean, 通常会用到这样的代码：
ApplicationContext appContext = new ClassPathXmlApplicationContext("applicationContext-common.xml");  
AbcService abcService = (AbcService)appContext.getBean("abcService");  

但是这样就会存在一个问题：因为它会重新装载applicationContext-common.xml并实例化上下文bean，如果有些线程配置类也是在这个配置文件中，那么会造成做相同工作的的线程会被启两次。一次是web容器初始化时启动，另一次是上述代码显示的实例化了一次。当于重新初始化一遍！！！！这样就产生了冗余。

解决方法
不用类似new ClassPathXmlApplicationContext()的方式，从已有的spring上下文取得已实例化的bean。通过ApplicationContextAware接口进行实现。

当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得ApplicationContext中的所有bean。换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象。

package com.supconit.zhgl.web.common;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

package com.supconit.zhgl.web.common;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

/**
 * @ClassName SpringUtils
 * @Description 解决Filter中注入Bean失败
 * @Author 刘嘉杰
 * @Date 2019/12/2 11:06
 * @Version 1.0
 */
//在spring的配置文件中，注册方法类AppUtil。之所以方法类AppUtil能够灵活自如地获取ApplicationContext，就是因为spring能够为我们自动地执行了setApplicationContext。但是，spring不会无缘无故地为某个类执行它的方法的，所以，就很有必要通过注册方法类AppUtil的方式告知spring有这样子一个类的存在。这里我们使用@Component来进行注册
@Component
public class SpringUtils implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

//加载Spring配置文件时，如果Spring配置文件中所定义的Bean类实现了ApplicationContextAware 接口，那么在加载Spring配置文件时，会自动调用ApplicationContextAware 接口中的setApplicationContext,从而获取applicationContext实例
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (SpringUtils.applicationContext == null) {
            SpringUtils.applicationContext = applicationContext;
        }
    }

    public static ApplicationContext getApplicationContext() {
        //返回静态的成员ApplicationContext类型的对象
        return applicationContext;
    }

    /**
     * 根据配置的name获取bean实例
     * @param name
     * @return
     */
    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    /**
     * 根据类型获取bean实例
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T getBean(Class<T> clazz) {
        return getApplicationContext().getBean(clazz);
    }

    /**
     * 根据配置的name和类型获取bean实例
     * @param name
     * @param clazz
     * @param <T>
     * @return
     */
    public static <T> T getBean(String name, Class<T> clazz) {
        return getApplicationContext().getBean(name, clazz);
    }
}


使用场景:
可以利用ApplicationContextAware这个接口的特性,创建一个组件的工具类,从而方便我们在web项目的过滤器中,调用这个组件类,获取我们已经在spring的上下文中,实例化的组件
```



### Spring的过滤器的顺序

```xml
其实Spring中，web应用启动的顺序是：listener->filter->servlet，先初始化listener，然后再来就filter的初始化，再接着才到我们的dispathServlet的初始化.

一.使用spring等框架的web程序在Tomcat下的启动流程
1）Tomcat是根据web.xml来启动的。首先到web.xml
2）web.xml中负责启动spring和spring mvc。对应的启动配置文件分别是
启动spring mvc，并进行所有资源路径映射
<servlet>
<servlet-name>springMVC</servlet-name>
<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<init-param>
<param-name>contextConfigLocation</param-name>
<param-value>/WEB-INF/cfg/springmvc-servlet.xml</param-value>
</init-param>
<load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
<servlet-name>springMVC</servlet-name>
<url-pattern>/</url-pattern>
</servlet-mapping>

启动spring，通过ContextLoaderListener

<listener>
　　<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/cfg/spring.xml</param-value>
</context-param>
3）spring中对一些orm框架的启动，包括Mybatis/hibernate。orm框架的启动基本都是通过sqlsessionFactory bean来启动的。并配置各种bean到ioc容器中。包括datasource等。
4）web应用程序中，spring相当于程序运行的平台，spring对整个程序提高供ioc支持和aop支持。

spring提供注解如@service @repository @component将各种类注册到ioc容器中。通过设置scan package的方式，spring在启动时候会扫描包下的所有注解，并将它们注册到ioc容器中。并针对@autowired @resource，将一些bean从ioc容器中获取填充到bean的构造属性中。
spring会自动扫描如下包中的注解：

<context:component-scan base-package=”pagkage1[,pagkage2,…,pagkageN]”/>
以上可以看出spring所有的bean注入都是在spring.xml中配置的，所有的bean注入都在spring.xml中配置的。
@autowired @resource只针对于类的成员变量，不针对方法里的局部变量。
注：正是spring的ioc支持了controller层注入service，service注入dao。打通了各层之间的桥梁，省去了原来的new service(),new Dao()的方法。

web.xml加载过程（步骤）：
1.启动WEB项目的时候,容器(如:Tomcat)会去读它的配置文件web.xml.读两个节点:
<listener></listener> 和 <context-param></context-param>
2.紧接着,容器创建一个ServletContext(上下文),这个WEB项目所有部分都将共享这个上下文.
3.容器将<context-param></context-param>转化为键值对,并交给ServletContext.
4.容器创建<listener></listener>中的类实例,即创建监听.
5.在监听中会有contextInitialized(ServletContextEvent args)初始化方法,在这个方法中获得：
ServletContext = ServletContextEvent.getServletContext();
context-param的值 = ServletContext.getInitParameter(“context-param的键”);
6.得到这个context-param的值之后,你就可以做一些操作了.注意,这个时候你的WEB项目还没有完全启动完成.这个动作会比 所 有的Servlet都要早.
换句话说,这个时候,你对中的键值做的操作,将在你的WEB项目完全启动之前被执行.
7.举例.你可能想在项目启动之前就打开数据库.
那么这里就可以在<context-param>中设置数据库的连接方式,在监听类中初始化数据库的连接.
8.这个监听是自己写的一个类,除了初始化方法,它还有销毁方法.用于关闭应用前释放资源.比如说数据库连接的关闭.

web.xml节点加载顺序：
可以肯定的是，节点的加载顺序与它们在 web.xml 文件中的先后顺序无关。即不会因为 filter 写在 listener 的前面而会先加载 filter。最终得出的结论是：listener -> filter -> servlet

    同时还存在着这样一种配置节点：context-param，它用于向 ServletContext 提供键值对，即应用程序上下文信息。我们的 listener, filter 等在初始化时会用到这些上下文中的信息，那么 context-param 配置节是不是应该写在 listener 配置节前呢？实际上 context-param 配置节可写在任意位置，因此真正的加载顺序为：
context-param -> listener -> filter -> servlet

对于某类配置节而言，与它们出现的顺序是有关的。以 filter 为例，web.xml 中当然可以定义多个 filter，与 filter 相关的一个配置节是 filter-mapping，这里一定要注意，对于拥有相同 filter-name 的 filter 和 filter-mapping 配置节而言，filter-mapping 必须出现在 filter 之后，否则当解析到 filter-mapping 时，它所对应的 filter-name 还未定义。web 容器启动时初始化每个 filter 时，是按照 filter 配置节出现的顺序来初始化的，当请求资源匹配多个 filter-mapping 时，filter 拦截资源是按照 filter-mapping 配置节出现的顺序来依次调用 doFilter() 方法的。
   servlet 同 filter 类似，此处不再赘述。
【加载Spring】
   比如filter 需要用到 bean ，但加载顺序是： 先加载filter 后加载spring，则filter中初始化操作中的bean为null；
   所以，如果过滤器中要使用到 bean，可以将spring 的加载 改成 Listener的方式 :
org.springframework.web.context.ContextLoaderListener 最终结论：
       web.xml 的加载顺序是：[context-param -> listener -> filter -> servlet -> spring] ，而同类型节点之间的实际程序调用的时候的顺序是根据对应的 mapping 的顺序进行调用的。


```



### java.lang.NoSuchFieldError: INSTANCE异常解决方法

```
当出现这种信息的时候是因为项目里有两个httpClient.jar包，编译器默认使用版本低的包，导致你的sdk或者api链接版本不兼容,我这里使用ali的oss对象存储，在获取连接的时候发现这个错误，检查jar包的时候才发现，里面有很多包是多个版本，之前在调试百度AI的时候导了一部分包，版本比ali SDK的低一些，把所有的低版本从项目移除问题就解决了。
```



### spring重定向传送对象

```java
可以利用spring的RedirectAttributes类,利用addFlashAttribute(key,value)方法添加属性;

在重定向执行之前,所有的flash属性会被复制到会话中,在重定向后,存在会话中的flash属性会被取出,并从会话中转移到模型之中.
```



### RequestContextHolder使用技巧

```java
//在Web开发中，service层或者某个工具类中需要获取到HttpServletRequest对象还是比较常见的。一种方式是将HttpServletRequest作为方法的参数从controller层一直放下传递，不过这种有点费劲，且做起来不是优雅；还有另一种则是RequestContextHolder，直接在需要用的地方使用如下方式取HttpServletRequest即可

HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder
        .getRequestAttributes()).getRequest();
```



### java的Date类不能用以前过时的方法,要不然转Oracle的timestamp会精度缺失

```java
示例
 Date date = new Date();
 Timestamp timestamp = new Timestamp(date.getTime());
 System.out.println("date.getTime():"+date.getTime());
 System.out.println("timestamp:"+timestamp);

输出的结果
 date.getTime():1547790163307
 timestamp:2019-01-18 13:42:43.307
     
 发现Date类转Oracle会出现后面的毫秒值
```



### pringboot的aop对注解实现aop

```java
//1.定义日志相关的注解

//2.定义aspect切面
package com.cenobitor.aop.aspect;

import com.cenobitor.aop.annotation.Action;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;
import java.lang.reflect.Method;

@Aspect
@Component
public class LogAspect {

    @Pointcut("@annotation(com.cenobitor.aop.annotation.Action)")
    public void annotationPoinCut(){}

    @After("annotationPoinCut()")
    public void after(JoinPoint joinPoint){
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        Action action = method.getAnnotation(Action.class);
        System.out.println("注解式拦截 "+action.name());
    }

    @Before("execution(* com.cenobitor.aop.service.DemoMethodService.*(..))")
    public void before(JoinPoint joinPoint){
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        System.out.println("方法规则式拦截,"+method.getName());
    }
}


//AOP注解说明：

//@Aspect 定义切面：切面由切点和增强（引介）组成(可以包含多个切点和多个增强)，它既包括了横切逻辑的定义，也包括了连接点的定义，SpringAOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入到切面所指定的链接点中。
//@Pointcut 定义切点：切点是一组连接点的集合。AOP通过“切点”定位特定的连接点。通过数据库查询的概念来理解切点和连接点的关系再适合不过了：连接点相当于数据库中的记录，而切点相当于查询条件。
//@Before ：在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可。
//@AfterReturning ： 在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值。
//@Afterthrowing： 主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名来访问目标方法中所抛出的异常对象。
//@After： 在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式。
//@Around： 环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint。
```



### 项目中@Transcational注解失效

```
当希望在某个方法中添加事务时，我们常常在方法头上添加@Transactional注解
容易让人忽略的是：方法上未加任何属性的@Transactional注解只能在抛出RuntimeException或者Error时才会触发事务的回滚，常见的非RuntimeException是不会触发事务的回滚的。

如果要在抛出 非RuntimeException时也触发回滚机制，需要我们在注解上添加 rollbackFor = { Exception.class }属性。

当然，上面事务回滚的前提是添加@Transactional注解的方法中不含有try{...}catch{...}捕获异常，使得程序运行过程中出现异常能顺利抛出，从而触发事务回滚。

在实际开发中，我们往往需要在方法中进行异常的捕获，从而对异常进行判断，为客户端返回提示信息。但是此时由于异常的被捕获，导致事务的回滚没有被触发，导致事务的失败。

1. 使用@Transactional注解，抛出@Transactional注解默认识别的RuntimeException
在catch语句里throw new RuntimeException();

2.使用@Transactional(rollbackFor = { Exception.class })，抛出捕获的非RuntimeException异常
在catch语句里throw e;

3.手动回滚
TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();

```



### swagger-ui测试文件上传报错,HttpMediaTypeNotSupportedException

```
@RequestBody means to parse JSON data into map or java beans and only support content type is "application/json;charset=UTF-8" 

stackoverflow上解释,@RequestBody注解会将json数据转化为map,然后仅支持contenttype为"application/json;charset=UTF-8"的数据,所以会出现这种问题

去掉@RequestBody注解就好了
```





## 数据库

### Oracle数据库查询字段值为空的内容

```sql
select * from tableName where field is not null
```

##### 

### Java异常之ORA-01745:无效的主机名/绑定变量名

```java
异常原因一:mybatis中的mapping映射时,sql语句中缺失逗号,且都好处有换行
解决方法:在缺失处加上","即可

异常原因二:当数据量过大的时候,拼接的sql过长,同样也会报这个异常
解决办法:分批插入
if (dataList.size() > 0) {
       new Thread() {
           @Override
           public void run() {
                //为了防止SQL语句超出长度出错，分成几次插入
                if(dataList.size()<=2000){
                    nodeDataService.save(dataList);
                }else{
                    int times = (int)Math.ceil( dataList.size()/2000.0 );
                    for(int i=0; i<times; i++ ){
                        System.out.println("分批插入："+ i);
                        nodeDataService.save(dataList.subList (i*2000,Math.min((i+1)*2000, dataList.size()-1)));
                    }
                }
           }
       }.start();
 }

```





### Oracle数据库进行表分区的操作

```sql
--使用Oracle Database 11g可以创建新类型的Interval分区表，Interval类型分区表，可以根据加载数据，自动创建指定间隔的分区。

--1 创建按月区分的分区表
Create table intervalpart
(
    c1 number, 
    c2 varchar2(10), 
    c3 date
)
partition by range (c3)
interval(numtoyminterval(1,'MONTH'))
(
partition part1 values less than (to_date('09/15/2007','MM/DD/YYYY')),
partition part2 values less than (to_date('10/15/2007','MM/DD/YYYY')),
partition part3 values less than (to_date('11/15/2007','MM/DD/YYYY'))
)

--2 创建以天为间隔的分区表
create table sales
(
	sales_id    number,
	sales_dt    date
)
partition by range (sales_dt)
INTERVAL (NUMTODSINTERVAL(1,'day'))
(
	partition p090101 values less than (to_date('2019-01-18	','yyyy-mm-dd'))
);

--观察自动创建的表分区
select table_name,partition_name from user_tab_partitions;
```



### oracle数据库里时间类型0:00:00无法显示,导致无法查表

```
解决方法一
通过to_date()函数将字符串类型的数据转换成时间格式的数据
select * from t_route_info t where to_char(t.find_time) >= to_date('2019-1-17 00:00:00','yyyy/mm/dd hh24:mi:ss') and t.find_time <= to_date('2019-1-17 23:59:59','yyyy/mm/dd hh24:mi:ss')
解决方法二
通过to_char()函数将时间转换成当天的0点,只要时间大于等于当天0:0:0,小于第二天0:0:0就可以查出当天的数据
select * from t_route_info t where t.find_time >= (select to_char(sysdate-2) from dual) and t.find_time < (select sysdate+1 from dual)
```



### 获取排序后的第一条记录的

```sql
select * from (select * from testStudent order by id desc) where rownum=1;
```



### Oracle通过指定列的权重进行排序

```sql
order by 子句里含有decode函数时，decode函数里的第一个参数，是order by排序时要针对的字段（对象，对哪些字段进行排序操作），而decode函数则是影响order by排序时数据行的顺序
如:
SELECT * FROM T_BASEDATA_ROUTE T WHERE XZDJ in ('G9','GA','S') ORDER BY decode(T.XZDJ,'GA', 1,'G9', 2, 'S', 3, 'X', 4), T.LXJC DESC

就会按照我给的指定顺序进行排序
```



### oracle的存储过程在plsql上执行

```shell
为了在PL/SQL中执行存储过程
1.打开命令窗口
2.执行:
	exec '存储过程名'
```



### merge into的用法及可能遇到的问题

```plsql
用法:
MERGE INTO table_name alias1 
USING (table|view|sub_query) alias2
ON (join condition) 
WHEN MATCHED THEN 
    UPDATE 
    SET col1 = col_val1, 
        col2     = col2_val 
WHEN NOT MATCHED THEN 
    INSERT (column_list) VALUES (column_values); 
	
判断Ｂ表和Ａ表是否满足ON中条件，如果满足则用B表去更新A表，如果不满足，则将B表数据插入A表

问题:
1.使用merge into语法的时候,下面的插入和更新语句都不能带表名,要不然会出现,缺失set关键字的bug,insert 也不能携带into 关键字,否则会出现缺失values的bug
2.update语句中不能对on里面的值在进行赋值了,要不然会报错'无法更新on子句中引用的列t1.xxx'
3.首先我们要知道merge into存在的意义是什么！！！使用merge into是为了根据匹配条件on(condition)利用table_source 的数据更新合并table_target的数据。
merge into的内部处理是将table_source的每一条记录和table_target的每一条记录对比匹配，匹配到符合条件的记录就会进行修改，匹配不到的话就会insert。如果table_source的匹配列中有重复值的话，等到第二次重复的列值匹配的时候，就会将第一次的update后的值再一次update,就是说合并后的table_target中会丢失在table_source中的记录！！！如果记录丢失的话，两表合并的意义何在？！！因此我们使用merge into要注意：源表匹配列中不能有重复值，否则无法匹配（报错！     ）。 

4.MERGE INTO T T1
USING (SELECT a,b FROM T WHERE t.a='1001') T2
ON ( T1.a=T2.a)
WHEN MATCHED THEN
  UPDATE SET T1.b = 2
WHEN NOT MATCHED THEN 
  INSERT (a,b) VALUES('1001',2);
  以上的语句貌似很对是吧，实际上，该语句只能进行更新，而无法进行Insert，错误在哪里呢？

其实在Oracle中Merge语句原先是用来进行整表的更新用的，也就是ETL工具比较常用的语法，重点是在Using上。

用中文来解释Merge语法，就是：

在alias2中Select出来的数据，每一条都跟alias1进行 ON (join condition)的比较，如果匹配，就进行更新的操作(Update),如果不匹配，就进行插入操作(Insert)。

因此，严格意义上讲，”在一个同时存在Insert和Update语法的Merge语句中，总共Insert/Update的记录数，就是Using语句中alias2的记录数。”

以上这句话也就很好的解释了在上面写的语句为何只能进行Update，而不能进行Insert了，因为都Select不到数据，如何能进行Insert呢:)
改正好的
案例一
MERGE INTO T T1
USING (SELECT '1001' AS a,2 AS b FROM dual) T2
ON ( T1.a=T2.a)
WHEN MATCHED THEN
  UPDATE SET T1.b = T2.b
WHEN NOT MATCHED THEN 
  INSERT (a,b) VALUES(T2.a,T2.b);
案例二
MERGE INTO T T1
USING  dual 
ON ( T1.a='参数')
WHEN MATCHED THEN
  UPDATE SET T1.b = T2.b
WHEN NOT MATCHED THEN 
  INSERT (a,b) VALUES(T2.a,T2.b);
```



### oracle数据误删除恢复

```plsql
1.选择需要恢复的时间
select * from table_name as of timestamp to_timestamp(‘2017-12-20 08:29:00’,’yyyy-mm-dd hh24:mi:ss’);

2.闪回
flashback table table_name to timestamp to_timestamp(‘2017-12-20 08:29:00’,’yyyy-mm-dd hh24:mi:ss’);

3.注：如果报错ORA-08189: cannot flashback the table because row movement is not enabled 就输入下面的一段,开启行迁移,就可以了。
alter table table_name enable row movement;

```



### sql语句left join连表时,on后多条件无效

```plsql
ON 条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从 B 表中检索数据行。

如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据

在匹配阶段 WHERE 子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE 子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。
错误示例:
 SELECT * FROM product LEFT JOIN product_details
         ON (product.id = product_details.id)
         AND   product_details.id=2;
这么写,and 后面的product_details.id = 2 这个条件不生效;

正确示例:
SELECT * FROM product LEFT JOIN product_details
         ON (product.id = product_details.id)
         WHERE product_details.id=2;
在on条件匹配完成后,再调用where子句进行条件的查找


```



### mybtis mapperLocations,basePackge多数据路径配置

```xml
单数据配置
    <bean id="sqlSessionFactory2" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource2" />
        <property name="mapperLocations" value="classpath*:com/loongshawn/dao/impl/mapper2/pmp/*.xml" />
        <property name="typeAliasesPackage" value="com.autonavi.domain" />
    </bean>

    <!-- mybatis.spring自动映射 -->
    <bean id="mybatisMapperScanner2" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.loongshawn.pmp" />
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory2" />
    </bean>

多数据配置
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="mapperLocations">
            <array>
                <value>classpath:com/loongshawn/dao/impl/mapper/*.xml</value>
                <value>classpath:com/loongshawn/dao/impl/mapper3/pmc/*.xml</value>
            </array>
        </property>
        <property name="typeAliasesPackage" value="com.autonavi.domain" />
    </bean>

    <!-- mybatis.spring自动映射 -->
    <bean id="mybatisMapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.loongshawn.dao.impl.mapper,com.loongshawn.dao.impl.mapper3" />
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
    </bean>
```



### Oracle里的单引号怎么转义

```plsql
在转义特殊字符的时候通常使用的就是单引号:
select 'it''s a bird' from dual

在oracle中使用q' 来对特殊字符进行转义。q'转义符通常后面使用!  []   {}  ()  <>等转义符号:
select q'[it's a bird]' from dual
```



### oracle中的start with的用法

```plsql
Oracle 提供了start with connect by 语法结构可以实现递归查询。

语法结构
start with condition  connect by  condition （含 prior 关键字)

start with conditon 给出的seed 数据的范围, connect by  后面给出了递归查询的条件,prior 关键字表示父数据，prior 条件表示子数据需要满足父数据的什么条件。
```



### oracle数据库查看所有表

```sql
select * from all_tables
--后面的条件,看你自己写啥东西
```



### union语法无法order by 一同使用

```
union的子句中如果以order by 结尾会报sql未正常结束
```



### mybatis返回id的方式

```xml
  
  ## 在mapper文件中添加    keyProperty="id" useGeneratedKeys="true"
  
  <insert id="insertUser"  keyProperty="id" useGeneratedKeys="true">
	INSERT INTO serv_user(
			id,
			name,
			password,
			open_id
	) VALUES (
			#{id},
			#{name},
			#{password},
			#{openId}
)
</insert>
```


## 中间件

## 软件

### plsql的commad命令窗口,回车一直换行,无法运行,该怎么结束

```
在你的代码撰写完成后,换行,输入"/"即可
```



### Idea 启动时报错 Address localhost:1099 is already in use

```
//首先进入cmd窗口
输入:
netstat -ano|findstr 1099
然后会查询处使用这个1099端口的服务,以及他的进程Id
//然后,删除
taskkill -f -pid 上面查询的进程id
```



### 在idea中编写xml文件的时候出现Tag name excepted的问题

```sql
起因：因为要在数据库选取前5的数据
select rownum,t.* from 表 t where rownum <=15
把这段sql语句复制进idea的xml文件的select标号当中，却发现在<=符号出现了Tag name execped
在网上搜了一下，发现了有人说可以使用<![CDATA[<=]]> 原因是：xml文件的某些特殊字符是自动转义的, xml解析器会忽视CDATA中的内容

1.在 XML 元素中，"<" 和 "&" 是非法的。
```

| &lt;   | <    | 小于   |
| ------ | ---- | ------ |
| &gt;   | >    | 大于   |
| &amp;  | &    | 和号   |
| &apos; | '    | 省略号 |
| &quot; | "    | 引号   |



### 使用Postman测试webservice接口

```
1.设置url
2.设置请求模式为:Post
3.设置header:添加Content-type,值为text/xml;charset=utf-8
4.设置body:勾选raw
5.输入body内容

body内容如何输入:
谷歌浏览器安装插件:Wizdler,它可以解析wsdl文件,生成soap信息
步骤:
>1.在浏览器访问webservice地址:如http://172.16.13.204:8080/hzzhglshare/webservice/event1?wsdl
>2.点击Wizdler,就会弹出查询出的接口信息,选择你需要的,拷贝即可

```



### Plsql报错ORA-0131:Insufficient privileges

```
使用plsql test窗口调试报错
报错信息：
ORA-0131 : Insufficient privileges.
Note: Debugging requires the DEBUG CONNECT SESSION system privilege.

解决办法：
根据NOTE提示给用户授权即可

SQL > GRANT debug any procedure, debug connect session to 用户;

授权后，重新登录，可以debug procedure ，按钮也恢复正常！
```



### plsql中文为?

+ 第一步查看本机字符集

```sql
select userenv('language') from dual
```

+ 第二步设置系统变量
  + 右键计算机>选择属性>高级系统设置>高级选项>选择环境变量
  + 设置两个系统变量
    +  LANG=zh_CN.GBK 
    +  NLS_LANG=AMERICAN_AMERICA.ZHS16GBK (这里填你数据库查询出来的即可)



### dos窗口查看class文件的运行过程

```shell
方法一:
javap -verbose className

方法二:
vim className
如果乱码,输入:%!xxd,即可转换为16进制显示
```



### 监听某个地址的端口是否可以使用

```shell
第一步:
ping 地址

第二步:
telnet 测试远程某一个ip的端口是否开放

注意:在使用telnet前,需要查看windows死都开启了telnet客户端
控制面板->程序->程序->启动或国币windows功能->telnet客户端
```



### idea打jar包的正确步骤

```
1.打开idea，这个不用多说了，open一个工程
2.点击菜单栏File-->Project Structure打开Project Structure
3.点+按钮，选择JAR--》From Modules.....打开create jar from modules对话框
4.下面这一步比较重要，我就曾经入坑，最后打出的jar包缺少main-class属性导致无法执行，这里选择MAIN CLASS，选择你要打成jar包的main class，然后修改MANIFEST.MF的存放路径 ，默认是..../src/... 务必改为 .../src
5.点OK进入下一步，如果弹出如下的错误提示，那是因为之前曾经打过jar，生成了MANIFEST.MF文件，删除这个文件就可以了
6.后面都不用改了，最多改改JAR的输出路径
7.jar输出后，然后就要执行BUILD了，否则输出目录下面是看不到jar的
```



## MAVEN

### maven手动导入jar包到本地仓库

+ 使用cmd进入maven安装目录下的bin
+ 运行

```cmd
mvn install:install-file -Dfile=jar包的路径 -DgroupId=gruopId中的内容 -DartifactId=actifactId的内容 -Dversion=version的内容 -Dpackaging=jar

如
mvn install:install-file -Dfile=J:\农信\三资\银企生成证书和签名验签\bce\bcprov-jdk16-146.jar -DgroupId=org.bouncycastle -DartifactId=bcprov-jdk16-146 -Dversion=1.4.6 -Dpackaging=jar
```



### maven打包报错--错误: 程序包COM.SUN.ISTACK.INTERNAL不存在

```xml
<!-- 解决maven命令编译报错，因为rt.jar 和jce.jar在jre的lib下面，不在jdk的lib下面，
                        导致maven找不到（java7以后会出现这个问题）-->
     <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <compilerArguments>
    <!-- 解决maven命令编译报错，因为rt.jar 和jce.jar在jre的lib下面，不在jdk的lib下面，
                        导致maven找不到（java7以后会出现这个问题）-->
                        <bootclasspath>${java.home}\lib\rt.jar;${java.home}\lib\jce.jar</bootclasspath>
                    </compilerArguments>
                </configuration>
            </plugin>
        </plugins>
    </build>
                   
```



## LINUX

### windows和linux之间,"/","\\","\\\\"的区别

```
简单来说可以这样分别
/ 用于linux中目录的分割，比如cd /data/farm
\ 用于windows中目录的分割，比如cd \Windows
\\ 则是用户访问windows的一个共享目录需要用到这个 \\sharefolder
```



### nohup命令的介绍

```shell
nohup
nohup 命令运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号。在注销后使用 nohup 命令运行后台中的程序。要运行后台中的 nohup 命令，添加 & （ 表示“and”的符号）到命令的尾部。

nohup 是 no hang up 的缩写，就是不挂断的意思。

nohup命令：如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用nohup命令。该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。

在缺省情况下该作业的所有输出都被重定向到一个名为nohup.out的文件中。

回到顶部
案例
1. nohup command > myout.file 2>&1 &   

在上面的例子中，0 – stdin (standard input)，1 – stdout (standard output)，2 – stderr (standard error) ；
2>&1是将标准错误（2）重定向到标准输出（&1），标准输出（&1）再被重定向输入到myout.file文件中。
2. 0 22 * * * /usr/bin/python /home/pu/download_pdf/download_dfcf_pdf_to_oss.py > /home/pu/download_pdf/download_dfcf_pdf_to_oss.log 2>&1

这是放在crontab中的定时任务，晚上22点时候怕这个任务，启动这个python的脚本，并把日志写在download_dfcf_pdf_to_oss.log文件中

回到顶部
nohup和&的区别
& ： 指在后台运行

nohup ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&才是后台运行

 

&是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出

那么，我们可以巧妙的吧他们结合起来用就是
nohup COMMAND &
这样就能使命令永久的在后台执行
例如：
1. sh test.sh &  
将sh test.sh任务放到后台 ，即使关闭xshell退出当前session依然继续运行，但标准输出和标准错误信息会丢失（缺少的日志的输出）

将sh test.sh任务放到后台 ，关闭xshell，对应的任务也跟着停止。
2. nohup sh test.sh  
将sh test.sh任务放到后台，关闭标准输入，终端不再能够接收任何输入（标准输入），重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。
3. nohup sh test.sh  & 
将sh test.sh任务放到后台，但是依然可以使用标准输入，终端能够接收任何输入，重定向标准输出和标准错误到当前目录下的nohup.out文件，即使关闭xshell退出当前session依然继续运行。
```

### linux查看端口号占用

```shell
在linux使用过程中，需要了解当前系统开放了哪些端口，并且要查看开放这些端口的具体进程和用户，可以通过netstat命令进行简单查询

netstat命令各个参数说明如下：
	  -a:显示所有选项

      -t：指明显示TCP端口

      -u：指明显示UDP端口

      -l：仅显示监听套接字（所谓套接字就是使用应用程序能够读写与收发通讯协议（protocol）与资料的程序）

      -p：显示进程标识符和程序名称，每一个套接字/端口都属于一个程序

      -n：不进行DNS轮询，显示IP（可以加速操作）

即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况

netstat -ntlp     //查看当前所有tcp端口

netstat -ntulp | grep 80    //查看所有80端口使用情况

```



### java -jar xxx.jar在linux运行报错:no main manifest attribute

```
原因:
一般情况下，java 打包成 jar 包需要在  MANIFEST.MF 中指定 Main-Class 项，以便运行 java -jar xxx.jar 时找到对应的主类。因为-jar的含义就是后面跟的jar包是有main class可独立运行，所以需要在打包成jar包时指定这个类；否则，需要在执行的时候手动指定。

解决方案：
在运行jar包时，使用 -cp / --classpath 来手动指定。
eg：java -cp xxx.jar com.fresher.xxx.类名
```



### linux后台运行java的jar包

```shell
Linux 运行jar包命令如下：

方式一
java -jar shareniu.jar
特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出

那如何让窗口不锁定？
方式二
java -jar shareniu.jar &
&代表在后台运行。

特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。
继续改进，如何让窗口关闭时，程序仍然运行？

方式三
nohup java -jar shareniu.jar &
nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行
当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。

方式四
nohup java -jar shareniu.jar >/dev/null  &  
解释下 >temp.txt
command >out.file
command >out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。

可通过jobs命令查看后台运行任务

jobs
那么就会列出所有后台执行的作业，并且每个作业前面都有个编号。
如果想将某个作业调回前台控制，只需要 fg + 编号即可。
fg 23
 
查看某端口占用的线程的pid

netstat -nlp |grep :9181
 
```



### linux防火墙操作

```shell
查看已开放端口 
/etc/init.d/iptables status 

#开启80端口 
/sbin/iptables -I INPUT -p tcp --dport 80 -j ACCEPT 
#开启22端口 
/sbin/iptables -I INPUT -p tcp --dport 22 -j ACCEPT 
#删除端口（2表示上面的num列）
/sbin/iptables -D INPUT 2
 #保存配置 
/etc/rc.d/init.d/iptables save
 #重启服务 
/etc/rc.d/init.d/iptables restart


查看端口是否开放：lsof -i:80     有记录表示开放了
```



## git

### git撤回commit的内容

```
git reset --soft HEAD^
```



### 重新生成git的ssh key密钥

```
1.先查看 C:\Users\leoalasiga\.ssh 目录下是否有id_rsa,id_rsa.pub文件
2.打开gitbash窗口,输入
> ssh-keygen -t rsa -C "your_email@example.com"
3.打开 C:\Users\leoalasiga\.ssh 目录下的id_rsa.pub文件,将内容复制
4.在你的gitlab或者github的账户，打开SSH key标签
5.然后选择Add SSH key按钮，将刚刚复制的内容粘贴进去即可，然后点击add key。

```



### git设置远程地址

```
git查看地址
git remote -v

git修改远程地址
git remote set-url origin git@172.20.41.234:highway/hangzhou/hzzhglws.git
```



### git提交的时候,出现Untracked files

```shell
Untracked files:
  (use "git add <file>..." to include in what will be committed)

        .idea/

nothing added to commit but untracked files present (use "git add" to track)


我们在工作目录中新建一个.gitignore文件，在里面写上需要排除的,不想提交的文件,如:
/target
.classpath
.project
.settings
/.externalToolBuilders
*.iml
.idea
```



## nginx

### nginx 跳转不带端口，导致访问不了网站

````
场景:
访问主页没问题，登录后，提示找不到login页面。
从连接上，发现没有端口。如：www.xx.com.cn/login

原因:
nginx配置没有携带端口
listen 6609

location / {
proxy_pass http://127.0.0.1:8080;
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header Host $host:6609;//这个地方配置把端口带上就好了
}
#### 添加端口跟着走。应用登录后，链接地址就变成www.xx.com.cn:6609/login ###

````



### nginx: [emerg] unexpected “}”

```
nginx大括号里的每行语句y需要以';'结尾
```



## tomcat

### Post请求发送base64转码的图片的时候,接收方接到的参数为null

```xml
post请求理论上对参数的大小没有限制，但是服务器有限制，把Tomcat的server.xml里设置一下就好了

注：Tomcat的版本低于等于7，设置maxPostSize="0" 表示post参数无限大

Tomcat的版本大于等于8，设置maxPostSize="104857600" 表示post参数最大100MB

<Connector connectionTimeout="20000" port="80" protocol="HTTP/1.1" redirectPort="443" maxPostSize="104857600"/>
```



### Tomcat java web 禁用HTTP 方法

```xml
配置tomcat，conf/web.xml 或 应用的web.xml
<security-constraint>
        <web-resource-collection>
            <url-pattern>/*</url-pattern>
            <http-method>PUT</http-method>
            <http-method>DELETE</http-method>
            <http-method>HEAD</http-method>
            <http-method>OPTIONS</http-method>
            <http-method>TRACE</http-method>
        </web-resource-collection>
        <auth-constraint></auth-constraint>
    </security-constraint>
此方法，适用于静态资源和实现了doGet、doPost方法的servelt类的服务。一般现代web应用大多采用Spring MVC框架，DispatchServelet的父类重org.springframework.web.servlet.FrameworkServlet重写了javax.servlet.http.HttpServlet的doGet、doPost、doPut、doDelete、doOptions、doTrace，对应HTTP 的标准方法。

DispatchServelet处理每一个请求时，由javax.servlet.http.HttpServlet的service方法进行处理，因此，HTTP的标准方法都会被处理。单纯的配置web.xml无法禁用掉HTTP方法。

Spring MVC 禁用HTTP OPTIONS方法
在应用的web.xml中修改spring mvc的配置：
<servlet>
        <servlet-name>springServlet</servlet-name>
        <servlet-class>s2jh.biz.util.CustomerDispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-mvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
        <async-supported>true</async-supported>
    </servlet>
    <servlet-mapping>
        <servlet-name>springServlet</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
重写DispatcherServlet的doOptions方法：
```

```java
/**
 * 自定义 Spring MVC DispatcherServlet 
 * Disabled HTTP OPTIONS METHOD
 */
public class CustomerDispatcherServlet extends DispatcherServlet {
 
	private static final Logger LOGGER = LoggerFactory.getLogger(CustomerDispatcherServlet.class);
	
	
	private static final long serialVersionUID = 8018418118826214565L;
 
    private static final ResourceBundle lStrings = ResourceBundle.getBundle("javax.servlet.http.LocalStrings");
    
    private static final String METHOD_OPTIONS = "OPTIONS";
    
	@Override
	protected void doOptions(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException {
		methodNotAllowed(METHOD_OPTIONS, response);
		LOGGER.warn("HTTP OPTIONS DISABLED.");
	}
	
	/**
	 * DISABLED HTTP METHOD
	 * 
	 * @param methodName
	 * @param response
	 * @throws IOException
	 */
	private void methodNotAllowed(String methodName, HttpServletResponse response) throws IOException { 
		 String errMsg = lStrings.getString("http.method_post_not_supported");
         Object[] errArgs = new Object[1];
         errArgs[0] = methodName;
         errMsg = MessageFormat.format(errMsg, errArgs);
         
         response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, errMsg);
	}
	
}
```

```
使用命令测试：
 curl -v -X OPTIONS http:/localhost:8080/test.htm 
```



### 配置linux下tomcat的图片访问路径

```xml
1.找到你项目的tomcat路径
2.进入tomcat下的conf目录
3.编辑server.xml文件 vim server.xml
4.找到<Host name="localhost"  >
5.在它下面配置
    <Context  docBase="你图片文件的目录"  path="你想要访问的地址" />
6.重启tomcat即可
```



### tomcat8出现Could not initialize class sun.awt.X11GraphicsEnvironment问题

```
网站验证码突然无法显示，并报如下错误。之前也出现过这个错误，不过不是验证码，不管怎样反正都是一样的问题。

Caused by: java.lang.NoClassDefFoundError: Could not initialize class sun.awt.X11GraphicsEnvironment


在catalina.sh里加上一句“-Djava.awt.headless=true \”，问题解决。
经查，出现这种情况一般就是启动tomcat的用户无法访问Xserver，包括Xserver没有启动或者没有权限访问.

以下为网上关于Headless mode的解释：

1.什么是Headless mode？ 
Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。

 

2.何时使用和headless mode？
Headless模式虽然不是我们愿意见到的，但事实上我们却常常需要在该模式下工作，尤其是服务器端程序开发者。因为服务器（如提供Web服务的主机）往往可能缺少前述设备，但又需要使用他们提供的功能，生成相应的数据，以提供给客户端（如浏览器所在的配有相关的显示设备、键盘和鼠标的主机）。

 

3.如何使用和Headless mode？
一般是在程序开始激活headless模式，告诉程序，现在你要工作在Headless mode下，就不要指望硬件帮忙了，你得自力更生，依靠系统的计算能力模拟出这些特性来:
System.setProperty("java.awt.headless","true");

 

修改${TOMCAT_HOME}/bin/catalina.sh或${TOMCAT_HOME}/bin/catalina.bat文件：

在所有类似以下代码：
    "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Djava.security.manager \
      -Djava.security.policy=="$CATALINA_BASE"/conf/catalina.policy \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \

 

在尾部加上一句：
      -Djava.awt.headless=true \
 

修改后内容如下：
    exec "$_RUNJAVA" $JAVA_OPTS $CATALINA_OPTS \
      -Djava.endorsed.dirs="$JAVA_ENDORSED_DIRS" -classpath "$CLASSPATH" \
      -Dcatalina.base="$CATALINA_BASE" \
      -Dcatalina.home="$CATALINA_HOME" \
      -Djava.io.tmpdir="$CATALINA_TMPDIR" \
      -Djava.awt.headless=true \

 

直接搜索查到-Djava.io.tmpdir="$CATALINA_TMPDIR"这行，并在这一行下加入: 

-Djava.awt.headless=true \ 

总共有七处，改完重启即可解决。 
```